#!/bin/sh
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# NY-CLI - Terminal-based Anime Streaming Client
# Version: 1.0.0
# Author: Anjishnu Sengupta
# Website: https://nyanime.tech
# Repository: https://github.com/AnjishnuSengupta/ny-cli
#
# Inspired by ani-cli, powered by nyanime backend
# Just install and run - no configuration needed!
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

VERSION="2.0.0"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BACKEND CONFIGURATION (Pre-configured - no user setup needed)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# NyAnime Backend APIs
NYANIME_BASE="https://www.nyanime.tech"
ANIWATCH_API="https://nyanime-backend-v2.onrender.com"
CONSUMET_API="https://consumet-api-gs81.onrender.com"

# Firebase Configuration (NyAnime project)
FIREBASE_PROJECT_ID="nyanime-tech"
FIRESTORE_BASE="https://firestore.googleapis.com/v1/projects/${FIREBASE_PROJECT_ID}/databases/(default)/documents"

# User agent
USER_AGENT="Mozilla/5.0 (X11; Linux x86_64; rv:121.0) Gecko/20100101 Firefox/121.0"

# Local storage directories (XDG compliant)
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/ny-cli"
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/ny-cli"
DATA_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/ny-cli"

# Files
AUTH_FILE="$CONFIG_DIR/auth"
HISTORY_FILE="$DATA_DIR/history"
PENDING_SYNC_FILE="$DATA_DIR/pending_sync"

# Player (can be overridden with NYCLI_PLAYER env var)
PLAYER="${NYCLI_PLAYER:-mpv}"

# Sync interval (seconds)
SYNC_INTERVAL=10

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COLORS & STYLING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if [ -t 1 ]; then
    RED='\033[1;31m'
    GREEN='\033[1;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[1;34m'
    MAGENTA='\033[1;35m'
    CYAN='\033[1;36m'
    WHITE='\033[1;37m'
    DIM='\033[2m'
    BOLD='\033[1m'
    RESET='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' MAGENTA='' CYAN='' WHITE='' DIM='' BOLD='' RESET=''
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ASCII ART BANNER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

show_banner() {
    clear
    printf '%b' "${MAGENTA}"
    cat << 'EOF'

    â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—
    â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•      â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•”â•  â•šâ•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘         â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
    â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•          â•šâ•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•

EOF
    printf '%b' "${RESET}"
    printf '%b\n' "${DIM}${CYAN}         âŸ¨ Your Gateway to Anime Streaming âŸ©${RESET}"
    printf '%b\n' "${DIM}         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
    printf '%b\n\n' "${DIM}              v${VERSION} â€¢ ${CYAN}nyanime.tech${RESET}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UI HELPERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print_line() {
    printf '%b\n' "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
}

msg() {
    printf '%b\n' "${CYAN}â–¸ ${WHITE}$1${RESET}" >&2
}

msg_success() {
    printf '%b\n' "${GREEN}âœ“ ${WHITE}$1${RESET}"
}

msg_error() {
    printf '%b\n' "${RED}âœ— ${WHITE}$1${RESET}" >&2
}

msg_warn() {
    printf '%b\n' "${YELLOW}âš  ${WHITE}$1${RESET}"
}

msg_info() {
    printf '%b\n' "${BLUE}â„¹ ${WHITE}$1${RESET}"
}

prompt() {
    printf '%b' "${CYAN}â–¸ ${WHITE}$1${RESET}"
}

die() {
    msg_error "$1"
    exit 1
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UTILITY FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

check_deps() {
    for cmd in curl sed grep; do
        command -v "$cmd" >/dev/null 2>&1 || die "Missing required dependency: $cmd"
    done
    
    if ! command -v "$PLAYER" >/dev/null 2>&1; then
        if command -v mpv >/dev/null 2>&1; then
            PLAYER="mpv"
        elif command -v vlc >/dev/null 2>&1; then
            PLAYER="vlc"
        elif command -v iina >/dev/null 2>&1; then
            PLAYER="iina"
        else
            msg_warn "No video player found. Install mpv:"
            msg_info "  Arch: sudo pacman -S mpv"
            msg_info "  Ubuntu: sudo apt install mpv"
            msg_info "  macOS: brew install mpv"
        fi
    fi
}

init_dirs() {
    mkdir -p "$CONFIG_DIR" "$CACHE_DIR" "$DATA_DIR"
}

urlencode() {
    # URL encode for query string parameters
    printf '%s' "$1" | sed 's/ /%20/g; s/!/%21/g; s/"/%22/g; s/#/%23/g; s/\$/%24/g; s/&/%26/g; s/'\''/%27/g; s/(/%28/g; s/)/%29/g; s/+/%2B/g; s/,/%2C/g; s/:/%3A/g; s/;/%3B/g; s/=/%3D/g; s/?/%3F/g; s/@/%40/g'
}

# Base64 encode (use openssl or base64 command)
base64_encode() {
    if command -v base64 >/dev/null 2>&1; then
        printf '%s' "$1" | base64 -w0 2>/dev/null || printf '%s' "$1" | base64 2>/dev/null
    elif command -v openssl >/dev/null 2>&1; then
        printf '%s' "$1" | openssl base64 -A 2>/dev/null
    else
        printf '%s' "$1"
    fi
}

# Get proxied stream URL (using nyanime.tech stream proxy)
get_proxied_url() {
    local url="$1"
    local referer="${2:-https://megacloud.blog/}"
    
    # Encode headers as base64 JSON
    local headers_json="{\"Referer\":\"${referer}\"}"
    local headers_b64
    headers_b64=$(base64_encode "$headers_json")
    
    # Build proxy URL - URL encode the stream URL
    local encoded_url
    encoded_url=$(printf '%s' "$url" | sed 's/%/%25/g; s/ /%20/g; s/!/%21/g; s/"/%22/g; s/#/%23/g; s/\$/%24/g; s/&/%26/g; s/'\''/%27/g; s/(/%28/g; s/)/%29/g; s/+/%2B/g; s/,/%2C/g; s/:/%3A/g; s/;/%3B/g; s/=/%3D/g; s/?/%3F/g; s/@/%40/g')
    
    printf '%s/stream?url=%s&h=%s' "$NYANIME_BASE" "$encoded_url" "$headers_b64"
}

open_url() {
    if command -v xdg-open >/dev/null 2>&1; then
        xdg-open "$1" 2>/dev/null &
    elif command -v open >/dev/null 2>&1; then
        open "$1" 2>/dev/null &
    elif command -v wslview >/dev/null 2>&1; then
        wslview "$1" 2>/dev/null &
    else
        msg_info "Open this URL: $1"
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AUTHENTICATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

is_logged_in() {
    [ -f "$AUTH_FILE" ] && [ -s "$AUTH_FILE" ]
}

get_username() {
    is_logged_in && head -1 "$AUTH_FILE"
}

get_token() {
    is_logged_in && sed -n '2p' "$AUTH_FILE"
}

do_login() {
    printf "\n"
    printf '%b\n' "${MAGENTA}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}"
    printf '%b\n' "${MAGENTA}â”‚${RESET}  ${BOLD}ğŸ” Login to NyAnime${RESET}                            ${MAGENTA}â”‚${RESET}"
    printf '%b\n' "${MAGENTA}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${RESET}"
    printf '%b\n' "${MAGENTA}â”‚${RESET}  1. Sign up/login at nyanime.tech              ${MAGENTA}â”‚${RESET}"
    printf '%b\n' "${MAGENTA}â”‚${RESET}  2. Go to your Profile page                    ${MAGENTA}â”‚${RESET}"
    printf '%b\n' "${MAGENTA}â”‚${RESET}  3. Copy your User ID shown there              ${MAGENTA}â”‚${RESET}"
    printf '%b\n' "${MAGENTA}â”‚${RESET}  4. Paste it here                              ${MAGENTA}â”‚${RESET}"
    printf '%b\n' "${MAGENTA}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${RESET}"
    printf "\n"
    
    local login_url="https://www.nyanime.tech/signup"
    msg "Opening browser..."
    open_url "$login_url"
    
    msg_info "If browser didn't open, visit: ${login_url}"
    msg_info "After signing in, go to Profile to find your User ID"
    printf "\n"
    
    prompt "Your username: "
    read -r username
    [ -z "$username" ] && { msg_error "Login cancelled"; return; }
    
    prompt "Paste User ID: "
    read -r firebase_uid
    [ -z "$firebase_uid" ] && { msg_error "Login cancelled"; return; }
    
    # Verify the UID exists in Firebase by checking the user document
    msg "Verifying account..."
    local verify_resp
    verify_resp=$(curl -s --connect-timeout 10 --max-time 15 \
        "${FIRESTORE_BASE}/users/${firebase_uid}" 2>/dev/null)
    
    # Check if we got a valid response (user exists)
    if printf '%s' "$verify_resp" | grep -q '"fields"' 2>/dev/null; then
        printf '%s\n%s\n' "$username" "$firebase_uid" > "$AUTH_FILE"
        chmod 600 "$AUTH_FILE"
        printf "\n"
        msg_success "Welcome, ${username}! ğŸ‰"
        msg_info "Your watch history will sync to the cloud"
        # Fetch cloud history and merge with local
        fetch_and_merge_cloud_history
        # Try to sync any pending local watch history to cloud
        sync_pending_history
    else
        # User might not exist yet or network error - store locally anyway
        printf '%s\n%s\n' "$username" "$firebase_uid" > "$AUTH_FILE"
        chmod 600 "$AUTH_FILE"
        printf "\n"
        msg_success "Welcome, ${username}!"
        msg_warn "Could not verify account - history will sync when online"
    fi
}

do_logout() {
    if [ -f "$AUTH_FILE" ]; then
        local user
        user=$(get_username)
        rm -f "$AUTH_FILE"
        msg_success "Goodbye, ${user}!"
    else
        msg_info "Not logged in"
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WATCH HISTORY & CLOUD SYNC
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Check if online
is_online() {
    curl -s --connect-timeout 2 --max-time 3 "https://www.google.com" >/dev/null 2>&1
}

# Fetch cloud history and merge with local history
# This pulls watch history from the website and merges it with local history
fetch_and_merge_cloud_history() {
    is_logged_in || return 0
    is_online || return 0
    
    local firebase_uid
    firebase_uid=$(get_token)
    [ -z "$firebase_uid" ] && return 0
    
    msg "Syncing with cloud..."
    
    # Fetch history from the CLI history API (GET request)
    local response
    response=$(curl -s --connect-timeout 10 --max-time 30 \
        "${NYANIME_BASE}/api/cli/history" \
        -H "X-Firebase-UID: ${firebase_uid}" \
        2>/dev/null)
    
    # Check if we got valid history from the API
    if printf '%s' "$response" | grep -q '"success"' 2>/dev/null; then
        # Parse API format - contains animeSlug, animeTitle, episodeNum
        local cloud_tmp="${CACHE_DIR}/cloud_merged.tmp"
        > "$cloud_tmp"
        
        # Extract each history item with slug and title
        printf '%s' "$response" | tr '{' '\n' | grep '"animeSlug"' | while read -r item; do
            local slug title ep_num
            slug=$(printf '%s' "$item" | sed -n 's/.*"animeSlug"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
            title=$(printf '%s' "$item" | sed -n 's/.*"animeTitle"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
            ep_num=$(printf '%s' "$item" | sed -n 's/.*"episodeNum"[[:space:]]*:[[:space:]]*\([0-9]*\).*/\1/p')
            
            if [ -n "$slug" ] && [ -n "$title" ]; then
                [ -z "$ep_num" ] && ep_num=1
                # Check if this anime is already in local history
                if [ -f "$HISTORY_FILE" ]; then
                    if ! grep -q "^${slug}|" "$HISTORY_FILE" 2>/dev/null; then
                        # Add to local history (new entry from cloud)
                        local timestamp
                        timestamp=$(date +%s)
                        printf '%s|%s|%s|%s\n' "$slug" "$title" "$ep_num" "$timestamp" >> "$cloud_tmp"
                    fi
                else
                    local timestamp
                    timestamp=$(date +%s)
                    printf '%s|%s|%s|%s\n' "$slug" "$title" "$ep_num" "$timestamp" >> "$cloud_tmp"
                fi
            fi
        done
        
        # Merge cloud items into local history
        if [ -f "$cloud_tmp" ] && [ -s "$cloud_tmp" ]; then
            if [ -f "$HISTORY_FILE" ]; then
                # Append cloud items and deduplicate
                cat "$cloud_tmp" >> "$HISTORY_FILE"
                awk -F'|' '!seen[$1]++' "$HISTORY_FILE" > "${HISTORY_FILE}.tmp"
                mv "${HISTORY_FILE}.tmp" "$HISTORY_FILE"
            else
                mv "$cloud_tmp" "$HISTORY_FILE"
            fi
            local added_count
            added_count=$(wc -l < "$cloud_tmp" 2>/dev/null || echo 0)
            [ "$added_count" -gt 0 ] && msg_success "Added $added_count items from cloud"
        fi
        rm -f "$cloud_tmp" 2>/dev/null
        return 0
    fi
    
    msg_info "Cloud sync not available - using local history"
}

# Save watch progress to pending sync file (for offline support)
save_pending_sync() {
    local anime_slug="$1" anime_title="$2" ep_num="$3"
    local sync_time
    sync_time=$(date +%s)
    
    # Remove existing entry for this anime
    [ -f "$PENDING_SYNC_FILE" ] && grep -v "^${anime_slug}|" "$PENDING_SYNC_FILE" > "${PENDING_SYNC_FILE}.tmp" 2>/dev/null && mv "${PENDING_SYNC_FILE}.tmp" "$PENDING_SYNC_FILE"
    
    # Add new entry: anime_slug|anime_title|ep_num|sync_time
    printf '%s|%s|%s|%s\n' "$anime_slug" "$anime_title" "$ep_num" "$sync_time" >> "$PENDING_SYNC_FILE"
}

# Sync pending history to cloud via nyanime API
sync_pending_history() {
    [ ! -f "$PENDING_SYNC_FILE" ] && return 0
    [ ! -s "$PENDING_SYNC_FILE" ] && return 0
    
    is_logged_in || return 0
    is_online || return 0
    
    local firebase_uid
    firebase_uid=$(get_token)
    [ -z "$firebase_uid" ] && return 0
    
    local synced=0
    local temp_file="${PENDING_SYNC_FILE}.syncing"
    
    # Process each pending entry
    while IFS='|' read -r anime_slug anime_title ep_num sync_time; do
        [ -z "$anime_slug" ] && continue
        [ -z "$anime_title" ] && anime_title="$anime_slug"
        [ -z "$ep_num" ] && ep_num=1
        
        # Sync via nyanime API with slug-based format
        local response
        response=$(curl -s -X POST "${NYANIME_BASE}/api/cli/sync-watch" \
            -H "Content-Type: application/json" \
            -H "X-Firebase-UID: ${firebase_uid}" \
            -d "{\"animeSlug\": \"${anime_slug}\", \"animeTitle\": \"${anime_title}\", \"episodeNum\": ${ep_num}}" \
            --connect-timeout 5 --max-time 10 2>/dev/null)
        
        if printf '%s' "$response" | grep -q '"success"' 2>/dev/null; then
            synced=$((synced + 1))
        else
            # Keep failed entries for retry
            printf '%s|%s|%s|%s\n' "$anime_slug" "$anime_title" "$ep_num" "$sync_time" >> "$temp_file"
        fi
    done < "$PENDING_SYNC_FILE"
    
    # Replace pending file with failed entries only
    if [ -f "$temp_file" ]; then
        mv "$temp_file" "$PENDING_SYNC_FILE"
    else
        rm -f "$PENDING_SYNC_FILE"
    fi
    
    [ $synced -gt 0 ] && msg_success "Synced $synced items to cloud"
}

# Background sync daemon (called during playback)
start_sync_daemon() {
    local anime_slug="$1" anime_title="$2" ep_num="$3"
    
    # Create a background process that syncs every 10 seconds
    (
        while true; do
            sleep "$SYNC_INTERVAL"
            
            # Save to pending sync with slug and title
            save_pending_sync "$anime_slug" "$anime_title" "$ep_num"
            
            # Try to sync if online
            sync_pending_history >/dev/null 2>&1
        done
    ) &
    SYNC_PID=$!
}

stop_sync_daemon() {
    [ -n "${SYNC_PID:-}" ] && kill "$SYNC_PID" 2>/dev/null
    SYNC_PID=""
}

save_to_history() {
    local anime_slug="$1" title="$2" episode="$3"
    local timestamp
    timestamp=$(date +%s)
    
    # Save to local history - remove ALL existing entries for this anime (deduplicate)
    if [ -f "$HISTORY_FILE" ]; then
        grep -v "^${anime_slug}|" "$HISTORY_FILE" > "${HISTORY_FILE}.tmp" 2>/dev/null
        mv "${HISTORY_FILE}.tmp" "$HISTORY_FILE" 2>/dev/null || true
    fi
    
    # Create new entry and prepend to history
    local new_entry
    new_entry=$(printf '%s|%s|%s|%s\n' "$anime_slug" "$title" "$episode" "$timestamp")
    
    if [ -f "$HISTORY_FILE" ] && [ -s "$HISTORY_FILE" ]; then
        printf '%s\n' "$new_entry" | cat - "$HISTORY_FILE" > "${HISTORY_FILE}.tmp"
        mv "${HISTORY_FILE}.tmp" "$HISTORY_FILE"
    else
        printf '%s\n' "$new_entry" > "$HISTORY_FILE"
    fi
    
    # Keep only the most recent 50 entries and ensure no duplicates
    if [ -f "$HISTORY_FILE" ]; then
        awk -F'|' '!seen[$1]++' "$HISTORY_FILE" | head -50 > "${HISTORY_FILE}.tmp"
        mv "${HISTORY_FILE}.tmp" "$HISTORY_FILE"
    fi
    
    # Save to pending sync for cloud backup (slug, title, episode)
    save_pending_sync "$anime_slug" "$title" "$episode"
    
    # Try immediate sync if online
    sync_pending_history >/dev/null 2>&1 &
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ANIME API - Using NyAnime Backend (aniwatch-api)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# JSON parsing helpers (pure POSIX shell)
# Extract a JSON string value by key
json_get_string() {
    local json="$1" key="$2"
    printf '%s' "$json" | sed -n 's/.*"'"$key"'"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -1
}

# Extract a JSON number value by key
json_get_number() {
    local json="$1" key="$2"
    printf '%s' "$json" | sed -n 's/.*"'"$key"'"[[:space:]]*:[[:space:]]*\([0-9]*\).*/\1/p' | head -1
}

# Search for anime by title
# Returns: id|name|type|episodes lines
search_anime() {
    local query="$1"
    local encoded
    encoded=$(urlencode "$query")
    
    msg "Searching for '$query'..."
    
    local response
    response=$(curl -s --connect-timeout 10 --max-time 30 \
        "${ANIWATCH_API}/api/v2/hianime/search?q=${encoded}" \
        -H "User-Agent: $USER_AGENT" \
        -H "Accept: application/json" 2>/dev/null)
    
    [ -z "$response" ] && return 1
    
    # Extract just the animes array content (avoid other arrays like mostPopularAnimes)
    local animes_json
    animes_json=$(printf '%s' "$response" | sed -n 's/.*"animes":\[\(.*\)],".*/\1/p' 2>/dev/null)
    
    [ -z "$animes_json" ] && return 1
    
    # Save to temp file for line-by-line processing
    local tmp_file="${CACHE_DIR}/search_result.tmp"
    printf '%s' "$animes_json" | tr '}' '\n' | grep '"id"' > "$tmp_file" 2>/dev/null
    
    # Process each line and output id|name|type|episodes
    while IFS= read -r line; do
        local id name type sub
        id=$(printf '%s' "$line" | grep -oP '"id"\s*:\s*"\K[^"]+' 2>/dev/null)
        name=$(printf '%s' "$line" | grep -oP '"name"\s*:\s*"\K[^"]+' 2>/dev/null)
        type=$(printf '%s' "$line" | grep -oP '"type"\s*:\s*"\K[^"]+' 2>/dev/null)
        sub=$(printf '%s' "$line" | grep -oP '"sub"\s*:\s*\K[0-9]+' 2>/dev/null)
        [ -n "$id" ] && [ -n "$name" ] && printf '%s|%s|%s|%s\n' "$id" "$name" "${type:-TV}" "${sub:-0}"
    done < "$tmp_file"
    
    # Cleanup
    rm -f "$tmp_file" 2>/dev/null
}

# Get episodes for an anime
# Returns: ep_num|episode_id|title lines
get_episodes() {
    local anime_id="$1"
    
    msg "Loading episodes..."
    
    local response
    response=$(curl -s --connect-timeout 10 --max-time 30 \
        "${ANIWATCH_API}/api/v2/hianime/anime/${anime_id}/episodes" \
        -H "User-Agent: $USER_AGENT" \
        -H "Accept: application/json" 2>/dev/null)
    
    [ -z "$response" ] && return 1
    
    # Extract episodes array content
    local episodes_json
    episodes_json=$(printf '%s' "$response" | sed -n 's/.*"episodes":\[\(.*\)\]}.*/\1/p' 2>/dev/null)
    
    [ -z "$episodes_json" ] && return 1
    
    # Save to temp file for line-by-line processing
    local tmp_file="${CACHE_DIR}/episodes_result.tmp"
    printf '%s' "$episodes_json" | tr '}' '\n' | grep '"episodeId"' > "$tmp_file" 2>/dev/null
    
    # Process each line and output ep_num|episode_id|title|is_filler
    while IFS= read -r line; do
        local ep_id ep_num title is_filler
        ep_id=$(printf '%s' "$line" | grep -oP '"episodeId"\s*:\s*"\K[^"]+' 2>/dev/null)
        ep_num=$(printf '%s' "$line" | grep -oP '"number"\s*:\s*\K[0-9]+' 2>/dev/null)
        title=$(printf '%s' "$line" | grep -oP '"title"\s*:\s*"\K[^"]+' 2>/dev/null)
        is_filler="0"
        printf '%s' "$line" | grep -q '"isFiller"[[:space:]]*:[[:space:]]*true' && is_filler="1"
        [ -n "$ep_id" ] && [ -n "$ep_num" ] && printf '%s|%s|%s|%s\n' "$ep_num" "$ep_id" "${title:-Episode $ep_num}" "$is_filler"
    done < "$tmp_file"
    
    # Cleanup
    rm -f "$tmp_file" 2>/dev/null
}

# Get available servers for an episode
# Returns: server_name lines
get_servers() {
    local episode_id="$1"
    local encoded_ep
    encoded_ep=$(urlencode "$episode_id")
    
    local response
    response=$(curl -s --connect-timeout 10 --max-time 30 \
        "${ANIWATCH_API}/api/v2/hianime/episode/servers?animeEpisodeId=${encoded_ep}" \
        -H "User-Agent: $USER_AGENT" 2>/dev/null)
    
    [ -z "$response" ] && return 1
    
    # Extract server names from sub array
    printf '%s' "$response" | grep -o '"serverName"[[:space:]]*:[[:space:]]*"[^"]*"' | \
        sed 's/.*"\([^"]*\)"/\1/' | sort -u
}

# Get streaming sources for an episode
# Sets global variables: STREAM_URL, STREAM_REFERER, STREAM_SUBTITLES, STREAM_INTRO_START, STREAM_INTRO_END
get_stream() {
    local episode_id="$1"
    local server="${2:-hd-1}"
    local category="${3:-sub}"
    local encoded_ep
    encoded_ep=$(urlencode "$episode_id")
    
    msg "Getting stream (server: $server, category: $category)..."
    
    # Reset globals
    STREAM_URL=""
    STREAM_REFERER=""
    STREAM_SUBTITLES=""
    STREAM_INTRO_START=""
    STREAM_INTRO_END=""
    
    local response
    response=$(curl -s --connect-timeout 15 --max-time 45 \
        "${ANIWATCH_API}/api/v2/hianime/episode/sources?animeEpisodeId=${encoded_ep}&server=${server}&category=${category}" \
        -H "User-Agent: $USER_AGENT" \
        -H "Accept: application/json" 2>/dev/null)
    
    [ -z "$response" ] && return 1
    
    # Handle data wrapper
    if printf '%s' "$response" | grep -q '"data"' 2>/dev/null; then
        response=$(printf '%s' "$response" | sed 's/.*"data"[[:space:]]*:[[:space:]]*//' | sed 's/}[[:space:]]*$//')
    fi
    
    # Extract stream URL from sources array - must be inside "sources":[ section
    # The sources array contains the video, tracks array contains subtitles
    STREAM_URL=$(printf '%s' "$response" | sed -n 's/.*"sources"[[:space:]]*:[[:space:]]*\[.*"url"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -1)
    
    # Fallback: try extracting m3u8 URL directly
    [ -z "$STREAM_URL" ] && STREAM_URL=$(printf '%s' "$response" | grep -o '"url"[[:space:]]*:[[:space:]]*"[^"]*\.m3u8"' | head -1 | sed 's/.*"\([^"]*\)"/\1/')
    
    # Extract referer from headers
    STREAM_REFERER=$(printf '%s' "$response" | grep -o '"Referer"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"\([^"]*\)"/\1/')
    [ -z "$STREAM_REFERER" ] && STREAM_REFERER="https://megacloud.blog/"
    
    # Extract ALL subtitles from tracks array (excluding thumbnails)
    # Format: lang|url per line for all available subtitle tracks
    STREAM_SUBTITLES=""
    STREAM_SUBTITLES_ALL=""
    
    # Get all subtitle tracks - each track has "url" and "lang" fields
    # Exclude thumbnails track
    STREAM_SUBTITLES_ALL=$(printf '%s' "$response" | tr '{' '\n' | grep '"lang"' | grep -v -i 'thumbnails' | while read -r track; do
        lang=$(printf '%s' "$track" | sed -n 's/.*"lang"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
        url=$(printf '%s' "$track" | sed -n 's/.*"url"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
        [ -n "$url" ] && [ -n "$lang" ] && printf '%s|%s\n' "$lang" "$url"
    done)
    
    # Set default English subtitle for backward compatibility
    STREAM_SUBTITLES=$(printf '%s\n' "$STREAM_SUBTITLES_ALL" | grep -i '^English|' | head -1 | cut -d'|' -f2)
    
    # If no English, use first available
    [ -z "$STREAM_SUBTITLES" ] && STREAM_SUBTITLES=$(printf '%s\n' "$STREAM_SUBTITLES_ALL" | head -1 | cut -d'|' -f2)
    
    # Extract intro timestamps
    STREAM_INTRO_START=$(printf '%s' "$response" | sed -n 's/.*"intro"[[:space:]]*:[[:space:]]*{[^}]*"start"[[:space:]]*:[[:space:]]*\([0-9]*\).*/\1/p' | head -1)
    STREAM_INTRO_END=$(printf '%s' "$response" | sed -n 's/.*"intro"[[:space:]]*:[[:space:]]*{[^}]*"end"[[:space:]]*:[[:space:]]*\([0-9]*\).*/\1/p' | head -1)
    
    [ -n "$STREAM_URL" ] && return 0
    return 1
}

# Try multiple servers to get a working stream
get_stream_with_fallback() {
    local episode_id="$1"
    local category="${2:-sub}"
    
    # Servers to try in order of reliability
    local servers="hd-1 hd-2 megacloud"
    
    for server in $servers; do
        if get_stream "$episode_id" "$server" "$category"; then
            [ -n "$STREAM_URL" ] && return 0
        fi
    done
    
    # Try dub if sub failed
    if [ "$category" = "sub" ]; then
        msg_warn "No sub found, trying dub..."
        for server in $servers; do
            if get_stream "$episode_id" "$server" "dub"; then
                [ -n "$STREAM_URL" ] && return 0
            fi
        done
    fi
    
    return 1
}

# Get trending/home anime
# Returns: id|name lines
get_trending() {
    msg "Fetching trending..."
    
    local response
    response=$(curl -s --connect-timeout 10 --max-time 30 \
        "${ANIWATCH_API}/api/v2/hianime/home" \
        -H "User-Agent: $USER_AGENT" 2>/dev/null)
    
    [ -z "$response" ] && return 1
    
    # Handle data wrapper
    if printf '%s' "$response" | grep -q '"data"' 2>/dev/null; then
        response=$(printf '%s' "$response" | sed 's/.*"data"[[:space:]]*:[[:space:]]*//' | sed 's/}[[:space:]]*$//')
    fi
    
    # Parse trending animes (from trendingAnimes section)
    printf '%s' "$response" | tr '{' '\n' | grep '"id"' | while read -r line; do
        local id name
        id=$(json_get_string "$line" "id")
        name=$(json_get_string "$line" "name")
        [ -n "$id" ] && [ -n "$name" ] && printf '%s|%s\n' "$id" "$name"
    done | head -15
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VIDEO PLAYER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Build the stream URL (optionally through nyanime proxy for CORS bypass)
build_stream_url() {
    local url="$1"
    local use_proxy="${2:-0}"
    
    if [ "$use_proxy" = "1" ] && [ -n "$NYANIME_BASE" ]; then
        # Use nyanime.tech stream proxy for CORS bypass
        local headers_json="{\"Referer\": \"${STREAM_REFERER:-https://megacloud.blog/}\"}"
        local headers_b64
        headers_b64=$(printf '%s' "$headers_json" | base64 -w 0 2>/dev/null || printf '%s' "$headers_json" | base64 2>/dev/null)
        printf '%s/stream?url=%s&h=%s' "$NYANIME_BASE" "$(urlencode "$url")" "$headers_b64"
    else
        printf '%s' "$url"
    fi
}

play_video() {
    local url="$1" title="$2" subtitle="$3" referer="${4:-https://megacloud.blog/}"
    
    [ -z "$url" ] && die "No stream available"
    
    msg_success "Starting playback..."
    printf '%b\n' "  ${DIM}${title}${RESET}"
    
    # Show intro skip info if available
    if [ -n "$STREAM_INTRO_START" ] && [ -n "$STREAM_INTRO_END" ] && [ "$STREAM_INTRO_END" != "0" ]; then
        printf '%b\n\n' "  ${DIM}Intro: ${STREAM_INTRO_START}s - ${STREAM_INTRO_END}s (press 's' to skip)${RESET}"
    else
        printf '\n'
    fi
    
    case "$PLAYER" in
        mpv*)
            # Build mpv command with proper argument handling
            local mpv_cmd="$PLAYER"
            mpv_cmd="$mpv_cmd --force-media-title='$title'"
            
            # Use --referrer for HLS streams (passes referer to ffmpeg for segment requests)
            mpv_cmd="$mpv_cmd --referrer='$referer'"
            
            # Disable ytdl to prevent interference with HLS
            mpv_cmd="$mpv_cmd --ytdl=no"
            
            # Add all available subtitles so user can switch between languages
            if [ -n "$STREAM_SUBTITLES_ALL" ]; then
                # Write subtitle URLs to temp file - English first, then others
                local sub_file="${CACHE_DIR}/sub_urls.txt"
                # Put English first so it's the default track
                printf '%s\n' "$STREAM_SUBTITLES_ALL" | grep -i '^English|' | cut -d'|' -f2 > "$sub_file"
                printf '%s\n' "$STREAM_SUBTITLES_ALL" | grep -vi '^English|' | cut -d'|' -f2 >> "$sub_file"
                while IFS= read -r sub_url; do
                    [ -n "$sub_url" ] && mpv_cmd="$mpv_cmd --sub-files-append='$sub_url'"
                done < "$sub_file"
                rm -f "$sub_file"
                mpv_cmd="$mpv_cmd --slang=eng,en,English --sid=1 --sub-visibility=yes"
            elif [ -n "$subtitle" ]; then
                # Fallback to single subtitle file
                mpv_cmd="$mpv_cmd --sub-file='$subtitle' --sub-visibility=yes"
            fi
            
            # Add script for intro skip if available and intro times are valid
            if [ -n "$STREAM_INTRO_START" ] && [ -n "$STREAM_INTRO_END" ] && [ "$STREAM_INTRO_END" != "0" ]; then
                # Create a temporary script for intro skip
                local skip_script="${CACHE_DIR}/intro_skip.lua"
                cat > "$skip_script" << LUAEOF
-- Intro skip script
local intro_start = ${STREAM_INTRO_START}
local intro_end = ${STREAM_INTRO_END}
local skipped = false

mp.add_key_binding("s", "skip-intro", function()
    local pos = mp.get_property_number("time-pos", 0)
    if pos >= intro_start - 5 and pos <= intro_end then
        mp.set_property_number("time-pos", intro_end)
        mp.osd_message("Skipped intro")
    else
        mp.osd_message("No intro to skip")
    end
end)

mp.observe_property("time-pos", "number", function(_, pos)
    if pos and not skipped and pos >= intro_start and pos <= intro_start + 2 then
        mp.osd_message("Press 's' to skip intro", 5)
    end
end)
LUAEOF
                mpv_cmd="$mpv_cmd --script='$skip_script'"
            fi
            
            # Run mpv with direct URL (--referrer passes to ffmpeg for HLS segments)
            eval "$mpv_cmd '$url'"
            ;;
        vlc*)
            $PLAYER --meta-title="$title" --http-referrer="$referer" --play-and-exit "$url"
            ;;
        iina*)
            $PLAYER --mpv-force-media-title="$title" --mpv-referrer="$referer" "$url"
            ;;
        *)
            $PLAYER "$url"
            ;;
    esac
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN FEATURES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

do_search() {
    printf "\n"
    prompt "Search anime: "
    read -r query
    [ -z "$query" ] && return
    
    printf "\n"
    results=$(search_anime "$query")
    
    [ -z "$results" ] && msg_error "No results found for '$query'" && return
    
    printf '%b\n' "\n${CYAN}Search Results:${RESET}"
    print_line
    i=1
    printf '%s\n' "$results" | while IFS='|' read -r id title type eps_sub eps_dub; do
        local info=""
        [ -n "$type" ] && info="$type"
        [ -n "$eps_sub" ] && [ "$eps_sub" != "0" ] && info="$info, ${eps_sub} eps"
        [ -n "$info" ] && info=" ${DIM}($info)${RESET}"
        printf '%b\n' "  ${WHITE}$(printf '%2d' $i))${RESET} ${title}${info}"
        i=$((i + 1))
    done
    print_line
    
    printf "\n"
    prompt "Select [1-20]: "
    read -r choice
    [ "$choice" = "q" ] && return
    
    selected=$(printf '%s\n' "$results" | sed -n "${choice}p")
    [ -z "$selected" ] && return
    
    anime_id=$(printf '%s' "$selected" | cut -d'|' -f1)
    anime_title=$(printf '%s' "$selected" | cut -d'|' -f2)
    
    watch_anime "$anime_id" "$anime_title"
}

watch_anime() {
    local anime_id="$1" anime_title="$2"
    
    printf "\n"
    episodes=$(get_episodes "$anime_id")
    [ -z "$episodes" ] && msg_error "No episodes" && return
    
    ep_count=$(printf '%s\n' "$episodes" | wc -l)
    
    printf '%b\n' "\n${CYAN}${anime_title}${RESET} ${DIM}(${ep_count} eps)${RESET}"
    print_line
    
    if [ "$ep_count" -gt 20 ]; then
        printf '%s\n' "$episodes" | head -10 | while IFS='|' read -r num id title; do
            printf '%b\n' "  ${WHITE}$(printf '%3s' "$num"))${RESET} Episode $num"
        done
        printf '%b\n' "  ${DIM}     ... ($((ep_count - 15)) more) ...${RESET}"
        printf '%s\n' "$episodes" | tail -5 | while IFS='|' read -r num id title; do
            printf '%b\n' "  ${WHITE}$(printf '%3s' "$num"))${RESET} Episode $num"
        done
    else
        printf '%s\n' "$episodes" | while IFS='|' read -r num id title; do
            printf '%b\n' "  ${WHITE}$(printf '%3s' "$num"))${RESET} Episode $num"
        done
    fi
    print_line
    
    printf "\n"
    prompt "Episode [1-$ep_count]: "
    read -r ep_choice
    [ "$ep_choice" = "q" ] && return
    
    ep_line=$(printf '%s\n' "$episodes" | grep "^${ep_choice}|")
    [ -z "$ep_line" ] && msg_error "Invalid" && return
    
    episode_id=$(printf '%s' "$ep_line" | cut -d'|' -f2)
    play_episode "$anime_id" "$anime_title" "$ep_choice" "$episode_id" "$episodes"
}

play_episode() {
    local anime_id="$1" anime_title="$2" ep_num="$3" episode_id="$4" episodes="$5"
    
    printf "\n"
    
    # Get streaming sources with fallback to multiple servers
    if ! get_stream_with_fallback "$episode_id" "sub"; then
        msg_error "No stream available for this episode"
        return
    fi
    
    [ -z "$STREAM_URL" ] && msg_error "No stream URL found" && return
    
    # Save to history (slug, title, episode)
    save_to_history "$anime_id" "$anime_title" "$ep_num"
    
    # Start background sync daemon during playback (slug, title, episode)
    start_sync_daemon "$anime_id" "$anime_title" "$ep_num"
    
    # Play the video with referer header
    play_video "$STREAM_URL" "${anime_title} - Episode ${ep_num}" "$STREAM_SUBTITLES" "$STREAM_REFERER"
    
    # Stop sync daemon after playback ends
    stop_sync_daemon
    
    # Final sync attempt
    sync_pending_history >/dev/null 2>&1 &
    
    printf "\n"
    print_line
    printf '%b\n' "  ${WHITE}n)${RESET} Next  ${WHITE}r)${RESET} Replay  ${WHITE}s)${RESET} Select  ${WHITE}q)${RESET} Quit"
    print_line
    prompt "Choice: "
    read -r choice
    
    case "$choice" in
        n)
            next_ep=$((ep_num + 1))
            next_line=$(printf '%s\n' "$episodes" | grep "^${next_ep}|")
            if [ -n "$next_line" ]; then
                next_id=$(printf '%s' "$next_line" | cut -d'|' -f2)
                play_episode "$anime_id" "$anime_title" "$next_ep" "$next_id" "$episodes"
            else
                msg_info "No more episodes"
            fi
            ;;
        r) play_episode "$anime_id" "$anime_title" "$ep_num" "$episode_id" "$episodes" ;;
        s) watch_anime "$anime_id" "$anime_title" ;;
    esac
}

do_continue() {
    # First, try to fetch and merge cloud history if logged in
    if is_logged_in; then
        fetch_and_merge_cloud_history >/dev/null 2>&1
    fi
    
    # Also clean up any duplicates in local history
    if [ -f "$HISTORY_FILE" ]; then
        awk -F'|' '!seen[$1]++' "$HISTORY_FILE" > "${HISTORY_FILE}.tmp" 2>/dev/null
        mv "${HISTORY_FILE}.tmp" "$HISTORY_FILE" 2>/dev/null || true
    fi
    
    [ ! -f "$HISTORY_FILE" ] && msg_info "No history yet" && return
    
    # Try to sync any pending history first
    sync_pending_history >/dev/null 2>&1
    
    printf '%b\n' "\n${CYAN}Continue Watching:${RESET}"
    print_line
    
    i=1
    head -10 "$HISTORY_FILE" | while IFS='|' read -r id title episode ts; do
        printf '%b\n' "  ${WHITE}$(printf '%2d' $i))${RESET} $title ${DIM}(Ep $episode)${RESET}"
        i=$((i + 1))
    done
    print_line
    
    printf "\n"
    prompt "Select: "
    read -r choice
    [ "$choice" = "q" ] && return
    
    selected=$(sed -n "${choice}p" "$HISTORY_FILE")
    [ -z "$selected" ] && return
    
    anime_id=$(printf '%s' "$selected" | cut -d'|' -f1)
    anime_title=$(printf '%s' "$selected" | cut -d'|' -f2)
    last_ep=$(printf '%s' "$selected" | cut -d'|' -f3)
    
    episodes=$(get_episodes "$anime_id")
    next_ep=$((last_ep + 1))
    next_line=$(printf '%s\n' "$episodes" | grep "^${next_ep}|")
    
    if [ -n "$next_line" ]; then
        msg_info "Continuing Episode ${next_ep}"
        episode_id=$(printf '%s' "$next_line" | cut -d'|' -f2)
        play_episode "$anime_id" "$anime_title" "$next_ep" "$episode_id" "$episodes"
    else
        watch_anime "$anime_id" "$anime_title"
    fi
}

do_recommendations() {
    printf "\n"
    trending=$(get_trending)
    [ -z "$trending" ] && msg_error "Failed to fetch" && return
    
    printf '%b\n' "\n${CYAN}ğŸ“š Trending:${RESET}"
    print_line
    
    i=1
    printf '%s\n' "$trending" | while IFS='|' read -r id title; do
        printf '%b\n' "  ${WHITE}$(printf '%2d' $i))${RESET} $title"
        i=$((i + 1))
    done
    print_line
    
    printf "\n"
    prompt "Select: "
    read -r choice
    [ "$choice" = "q" ] && return
    
    selected=$(printf '%s\n' "$trending" | sed -n "${choice}p")
    [ -z "$selected" ] && return
    
    anime_id=$(printf '%s' "$selected" | cut -d'|' -f1)
    anime_title=$(printf '%s' "$selected" | cut -d'|' -f2)
    watch_anime "$anime_id" "$anime_title"
}

do_random() {
    printf "\n"
    msg "Finding random anime..."
    
    # Generate random search query from common anime terms for true randomness
    local random_terms="a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3"
    local term_count=29
    local rand_idx=$(awk 'BEGIN { srand(); print int(rand() * '"$term_count"') + 1 }')
    local query=$(printf '%s' "$random_terms" | tr ' ' '\n' | sed -n "${rand_idx}p")
    
    # Search with random letter/number to get diverse results
    local results
    results=$(search_anime "$query" 2>/dev/null)
    [ -z "$results" ] && { msg_error "Failed to find anime"; return; }
    
    # Pick random anime from results
    local count=$(printf '%s\n' "$results" | wc -l)
    local idx=$(awk 'BEGIN { srand(); print int(rand() * '"$count"') + 1 }')
    local selected=$(printf '%s\n' "$results" | sed -n "${idx}p")
    
    local anime_id=$(printf '%s' "$selected" | cut -d'|' -f1)
    local anime_title=$(printf '%s' "$selected" | cut -d'|' -f2)
    
    printf '%b\n\n' "\n${YELLOW}ğŸ² Random:${RESET} ${WHITE}${anime_title}${RESET}"
    prompt "Watch? [Y/n]: "
    read -r ans
    
    case "$ans" in
        [nN]*) return ;;
        *)
            episodes=$(get_episodes "$anime_id")
            first=$(printf '%s\n' "$episodes" | head -1)
            [ -n "$first" ] && {
                ep_id=$(printf '%s' "$first" | cut -d'|' -f2)
                play_episode "$anime_id" "$anime_title" "1" "$ep_id" "$episodes"
            }
            ;;
    esac
}

show_profile() {
    is_logged_in || { msg_info "Not logged in"; return; }
    
    local username
    username=$(get_username)
    
    printf '%b\n' "\n${MAGENTA}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}"
    printf '%b\n' "${MAGENTA}â”‚${RESET}  ${BOLD}ğŸ‘¤ ${username}${RESET}"
    printf '%b\n\n' "${MAGENTA}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${RESET}"
    
    # Show sync status
    if [ -f "$PENDING_SYNC_FILE" ] && [ -s "$PENDING_SYNC_FILE" ]; then
        local pending_count
        pending_count=$(wc -l < "$PENDING_SYNC_FILE")
        printf '%b\n' "  ${YELLOW}â³ ${pending_count} items pending sync${RESET}"
        printf '%b\n\n' "  ${DIM}Will sync when online${RESET}"
    fi
    
    printf '%b\n\n' "  ${WHITE}1)${RESET} Logout  ${WHITE}2)${RESET} Sync Now  ${WHITE}3)${RESET} Back"
    prompt "Choice: "
    read -r c
    case "$c" in
        1) do_logout ;;
        2) msg "Syncing..."; sync_pending_history ;;
    esac
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HELP & MENUS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

show_help() {
    printf '%b\n' "
${BOLD}NY-CLI${RESET} v${VERSION} - Terminal Anime Streaming

${CYAN}USAGE:${RESET}  ny-cli [OPTIONS] [QUERY]

${CYAN}OPTIONS:${RESET}
    -s, --search <q>    Search anime
    -c, --continue      Continue watching  
    -r, --random        Random anime
    -t, --trending      Show trending
    -l, --login         Login
    -L, --logout        Logout
    -h, --help          Help
    -v, --version       Version

${CYAN}EXAMPLES:${RESET}
    ny-cli                  Interactive mode
    ny-cli \"one piece\"      Quick search
    ny-cli -c               Continue watching

${CYAN}PLAYER CONTROLS (mpv):${RESET}
    Space  Play/Pause    f  Fullscreen
    â†/â†’    Seek 5s       q  Quit
    â†‘/â†“    Seek 60s      v  Subtitles
"
}

main_menu() {
    while true; do
        show_banner
        
        if is_logged_in; then
            local username
            username=$(get_username)
            printf '%b\n\n' "${CYAN}Welcome, ${WHITE}${username}${CYAN}! ğŸ‰${RESET}"
            
            printf '%b\n' "${CYAN}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}"
            printf '%b\n' "${CYAN}â”‚${RESET}  ${WHITE}1)${RESET} ğŸ‘¤ Profile                         ${CYAN}â”‚${RESET}"
            printf '%b\n' "${CYAN}â”‚${RESET}  ${WHITE}2)${RESET} â–¶ï¸  Continue Watching              ${CYAN}â”‚${RESET}"
            printf '%b\n' "${CYAN}â”‚${RESET}  ${WHITE}3)${RESET} ğŸ” Search                          ${CYAN}â”‚${RESET}"
            printf '%b\n' "${CYAN}â”‚${RESET}  ${WHITE}4)${RESET} ğŸ“š Trending                        ${CYAN}â”‚${RESET}"
            printf '%b\n' "${CYAN}â”‚${RESET}  ${WHITE}5)${RESET} ğŸ² Random                          ${CYAN}â”‚${RESET}"
            printf '%b\n' "${CYAN}â”‚${RESET}  ${WHITE}h)${RESET} â“ Help                            ${CYAN}â”‚${RESET}"
            printf '%b\n' "${CYAN}â”‚${RESET}  ${WHITE}q)${RESET} ğŸšª Exit                            ${CYAN}â”‚${RESET}"
            printf '%b\n\n' "${CYAN}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${RESET}"
            prompt "Choice: "
            read -r c
            
            case "$c" in
                1) show_profile ;;
                2) do_continue ;;
                3) do_search ;;
                4) do_recommendations ;;
                5) do_random ;;
                h|H) show_help; printf '%b' "\n${DIM}Press Enter...${RESET}"; read -r _ ;;
                q|Q) printf '%b\n\n' "\n${MAGENTA}Sayounara! ğŸ‘‹${RESET}"; exit 0 ;;
            esac
        else
            printf '%b\n\n' "${CYAN}Welcome! Sign in for all features.${RESET}"
            
            printf '%b\n' "${CYAN}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}"
            printf '%b\n' "${CYAN}â”‚${RESET}  ${WHITE}1)${RESET} ğŸ” Search                          ${CYAN}â”‚${RESET}"
            printf '%b\n' "${CYAN}â”‚${RESET}  ${WHITE}2)${RESET} ğŸ“š Trending                        ${CYAN}â”‚${RESET}"
            printf '%b\n' "${CYAN}â”‚${RESET}  ${WHITE}3)${RESET} ğŸ” Login                           ${CYAN}â”‚${RESET}"
            printf '%b\n' "${CYAN}â”‚${RESET}  ${WHITE}h)${RESET} â“ Help                            ${CYAN}â”‚${RESET}"
            printf '%b\n' "${CYAN}â”‚${RESET}  ${WHITE}q)${RESET} ğŸšª Exit                            ${CYAN}â”‚${RESET}"
            printf '%b\n\n' "${CYAN}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${RESET}"
            prompt "Choice: "
            read -r c
            
            case "$c" in
                1) do_search ;;
                2) do_recommendations ;;
                3) do_login ;;
                h|H) show_help; printf '%b' "\n${DIM}Press Enter...${RESET}"; read -r _ ;;
                q|Q) printf '%b\n\n' "\n${MAGENTA}Sayounara! ğŸ‘‹${RESET}"; exit 0 ;;
            esac
        fi
    done
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ENTRY POINT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

main() {
    check_deps
    init_dirs
    
    case "${1:-}" in
        -h|--help) show_help; exit 0 ;;
        -v|--version) printf "ny-cli %s\n" "$VERSION"; exit 0 ;;
        -l|--login) show_banner; do_login; exit 0 ;;
        -L|--logout) do_logout; exit 0 ;;
        -c|--continue) show_banner; do_continue; exit 0 ;;
        -r|--random) show_banner; do_random; exit 0 ;;
        -t|--trending) show_banner; do_recommendations; exit 0 ;;
        -s|--search)
            shift
            show_banner
            [ -n "$1" ] && {
                results=$(search_anime "$*")
                [ -n "$results" ] && {
                    printf '%b\n' "\n${CYAN}Results:${RESET}"
                    print_line
                    i=1
                    printf '%s\n' "$results" | while IFS='|' read -r id title type eps; do
                        local info=""
                        [ -n "$type" ] && info="$type"
                        [ -n "$eps" ] && [ "$eps" != "0" ] && info="$info, ${eps} eps"
                        [ -n "$info" ] && info=" ${DIM}($info)${RESET}"
                        printf '%b\n' "  ${WHITE}$(printf '%2d' $i))${RESET} ${title}${info}"
                        i=$((i + 1))
                    done
                    print_line
                    printf "\n"
                    prompt "Select: "
                    read -r c
                    selected=$(printf '%s\n' "$results" | sed -n "${c}p")
                    [ -n "$selected" ] && watch_anime "$(printf '%s' "$selected" | cut -d'|' -f1)" "$(printf '%s' "$selected" | cut -d'|' -f2)"
                } || msg_error "No results"
            }
            exit 0
            ;;
        "")
            main_menu
            ;;
        *)
            show_banner
            results=$(search_anime "$*")
            [ -n "$results" ] && {
                printf '%b\n' "\n${CYAN}Results:${RESET}"
                print_line
                i=1
                printf '%s\n' "$results" | while IFS='|' read -r id title type eps; do
                    local info=""
                    [ -n "$type" ] && info="$type"
                    [ -n "$eps" ] && [ "$eps" != "0" ] && info="$info, ${eps} eps"
                    [ -n "$info" ] && info=" ${DIM}($info)${RESET}"
                    printf '%b\n' "  ${WHITE}$(printf '%2d' $i))${RESET} ${title}${info}"
                    i=$((i + 1))
                done
                print_line
                printf "\n"
                prompt "Select: "
                read -r c
                selected=$(printf '%s\n' "$results" | sed -n "${c}p")
                [ -n "$selected" ] && watch_anime "$(printf '%s' "$selected" | cut -d'|' -f1)" "$(printf '%s' "$selected" | cut -d'|' -f2)"
            } || msg_error "No results"
            exit 0
            ;;
    esac
}

main "$@"
