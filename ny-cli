#!/bin/sh
# ny-cli - A terminal-based anime streaming client
# Inspired by ani-cli, powered by nyanime backend
# https://github.com/AnjishnuSengupta/ny-cli

version_number="1.0.0"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# API endpoints (your nyanime backend)
NYANIME_API="${NYCLI_API:-https://nyanime.tech}"
ANIWATCH_API="${NYCLI_ANIWATCH_API:-https://api.nyanime.tech}"
CONSUMET_API="${NYCLI_CONSUMET_API:-https://api.consumet.org}"

# Firebase configuration (from your nyanime project)
FIREBASE_API_KEY="${NYCLI_FIREBASE_API_KEY:-}"
FIREBASE_AUTH_DOMAIN="${NYCLI_FIREBASE_AUTH_DOMAIN:-}"
FIREBASE_PROJECT_ID="${NYCLI_FIREBASE_PROJECT_ID:-}"

# User agent
agent="Mozilla/5.0 (X11; Linux x86_64; rv:121.0) Gecko/20100101 Firefox/121.0"

# Directories
config_dir="${NYCLI_CONFIG_DIR:-${XDG_CONFIG_HOME:-$HOME/.config}/ny-cli}"
cache_dir="${NYCLI_CACHE_DIR:-${XDG_CACHE_HOME:-$HOME/.cache}/ny-cli}"
data_dir="${NYCLI_DATA_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/ny-cli}"

# Player settings
player="${NYCLI_PLAYER:-mpv}"
quality="${NYCLI_QUALITY:-best}"

# Colors
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
MAGENTA='\033[1;35m'
CYAN='\033[1;36m'
WHITE='\033[1;37m'
RESET='\033[0m'
DIM='\033[2m'
BOLD='\033[1m'

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ASCII ART & UI
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

show_banner() {
    clear
    printf "${MAGENTA}"
    cat << 'EOF'
    
    â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—
    â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•      â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•”â•  â•šâ•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘         â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
    â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•          â•šâ•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•
                                                
EOF
    printf "${RESET}"
    printf "${DIM}${CYAN}    âŸ¨ Your Gateway to Anime Streaming âŸ©${RESET}\n"
    printf "${DIM}    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}\n"
    printf "${DIM}    v${version_number} â€¢ Powered by nyanime.tech${RESET}\n\n"
}

show_mini_banner() {
    printf "${MAGENTA}â•­â”€${BOLD} NY-CLI ${RESET}${MAGENTA}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}\n"
}

show_neko() {
    printf "${YELLOW}"
    cat << 'EOF'
       /\_/\  
      ( o.o ) 
       > ^ <
      /|   |\
     (_|   |_)
EOF
    printf "${RESET}"
}

show_loading() {
    local msg="${1:-Loading}"
    printf "\r${CYAN}âŸ³ ${msg}...${RESET}"
}

show_success() {
    printf "\r${GREEN}âœ“ ${1}${RESET}\n"
}

show_error() {
    printf "\r${RED}âœ— ${1}${RESET}\n" >&2
}

show_info() {
    printf "${BLUE}â„¹ ${1}${RESET}\n"
}

show_warning() {
    printf "${YELLOW}âš  ${1}${RESET}\n"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UTILITIES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

die() {
    show_error "$*"
    exit 1
}

dep_check() {
    for dep in "$@"; do
        command -v "$dep" >/dev/null 2>&1 || die "Missing dependency: $dep. Please install it."
    done
}

ensure_dirs() {
    mkdir -p "$config_dir" "$cache_dir" "$data_dir"
}

# URL encode a string
url_encode() {
    printf '%s' "$1" | curl -Gso /dev/null -w '%{url_effective}' --data-urlencode @- "" | cut -c 3-
}

# JSON parsing helpers (using sed/grep for POSIX compatibility)
json_extract() {
    local key="$1"
    local json="$2"
    printf '%s' "$json" | sed -n 's/.*"'"$key"'"\s*:\s*"\([^"]*\)".*/\1/p' | head -1
}

json_extract_number() {
    local key="$1"
    local json="$2"
    printf '%s' "$json" | sed -n 's/.*"'"$key"'"\s*:\s*\([0-9]*\).*/\1/p' | head -1
}

# Open URL in browser
open_browser() {
    local url="$1"
    if command -v xdg-open >/dev/null 2>&1; then
        xdg-open "$url" 2>/dev/null &
    elif command -v open >/dev/null 2>&1; then
        open "$url" 2>/dev/null &
    elif command -v wslview >/dev/null 2>&1; then
        wslview "$url" 2>/dev/null &
    else
        show_warning "Could not open browser automatically."
        printf "${CYAN}Please open this URL manually:${RESET}\n"
        printf "${WHITE}${url}${RESET}\n"
    fi
}

# Interactive menu using fzf
menu_select() {
    local prompt="$1"
    shift
    if command -v fzf >/dev/null 2>&1; then
        printf '%s\n' "$@" | fzf --prompt="$prompt " --height=40% --reverse --cycle
    else
        # Fallback to simple numbered menu
        local i=1
        printf "${CYAN}%s${RESET}\n" "$prompt"
        for item in "$@"; do
            printf "${WHITE}%d)${RESET} %s\n" "$i" "$item"
            i=$((i + 1))
        done
        printf "${CYAN}Enter choice: ${RESET}"
        read -r choice
        i=1
        for item in "$@"; do
            [ "$i" = "$choice" ] && printf '%s' "$item" && return
            i=$((i + 1))
        done
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AUTHENTICATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

auth_file="$config_dir/auth.json"
user_file="$config_dir/user.json"

is_logged_in() {
    [ -f "$auth_file" ] && [ -s "$auth_file" ]
}

get_user_token() {
    if is_logged_in; then
        json_extract "idToken" "$(cat "$auth_file")"
    fi
}

get_user_id() {
    if is_logged_in; then
        json_extract "localId" "$(cat "$auth_file")"
    fi
}

get_user_email() {
    if is_logged_in; then
        json_extract "email" "$(cat "$auth_file")"
    fi
}

get_user_name() {
    if is_logged_in; then
        local name
        name=$(json_extract "displayName" "$(cat "$auth_file")")
        [ -z "$name" ] && name=$(get_user_email | cut -d'@' -f1)
        printf '%s' "$name"
    fi
}

# Firebase REST API Authentication
# Sign up with email/password
auth_signup() {
    local email="$1"
    local password="$2"
    
    [ -z "$FIREBASE_API_KEY" ] && die "Firebase API key not configured. Set NYCLI_FIREBASE_API_KEY"
    
    show_loading "Creating account"
    
    local response
    response=$(curl -s -X POST \
        "https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=${FIREBASE_API_KEY}" \
        -H "Content-Type: application/json" \
        -d "{\"email\":\"${email}\",\"password\":\"${password}\",\"returnSecureToken\":true}")
    
    local error
    error=$(printf '%s' "$response" | grep -o '"message":"[^"]*"' | cut -d'"' -f4)
    
    if [ -n "$error" ]; then
        show_error "Sign up failed: $error"
        return 1
    fi
    
    printf '%s' "$response" > "$auth_file"
    show_success "Account created successfully!"
    return 0
}

# Sign in with email/password
auth_signin() {
    local email="$1"
    local password="$2"
    
    [ -z "$FIREBASE_API_KEY" ] && die "Firebase API key not configured. Set NYCLI_FIREBASE_API_KEY"
    
    show_loading "Signing in"
    
    local response
    response=$(curl -s -X POST \
        "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=${FIREBASE_API_KEY}" \
        -H "Content-Type: application/json" \
        -d "{\"email\":\"${email}\",\"password\":\"${password}\",\"returnSecureToken\":true}")
    
    local error
    error=$(printf '%s' "$response" | grep -o '"message":"[^"]*"' | cut -d'"' -f4)
    
    if [ -n "$error" ]; then
        show_error "Sign in failed: $error"
        return 1
    fi
    
    printf '%s' "$response" > "$auth_file"
    show_success "Signed in successfully!"
    return 0
}

# OAuth browser flow (opens browser for Google sign-in)
auth_oauth() {
    [ -z "$FIREBASE_API_KEY" ] && die "Firebase API key not configured"
    [ -z "$FIREBASE_AUTH_DOMAIN" ] && die "Firebase auth domain not configured"
    
    # Generate a temporary local server to receive the token
    local port=9876
    local callback_url="http://localhost:${port}/callback"
    
    # Create a simple callback HTML page
    local callback_html="$cache_dir/callback.html"
    cat > "$callback_html" << 'HTMLEOF'
<!DOCTYPE html>
<html>
<head>
    <title>NY-CLI Authentication</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        .container { text-align: center; }
        h1 { color: #a855f7; }
        p { color: #94a3b8; }
        .success { color: #22c55e; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ‰ Authentication Successful!</h1>
        <p class="success">You can close this window and return to the terminal.</p>
        <p>NY-CLI is ready to use.</p>
    </div>
</body>
</html>
HTMLEOF

    printf "\n${CYAN}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}\n"
    printf "${CYAN}â”‚${RESET}  ${BOLD}Google Sign-In${RESET}                        ${CYAN}â”‚${RESET}\n"
    printf "${CYAN}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${RESET}\n"
    printf "${CYAN}â”‚${RESET}  Opening browser for authentication... ${CYAN}â”‚${RESET}\n"
    printf "${CYAN}â”‚${RESET}  Complete sign-in in your browser.     ${CYAN}â”‚${RESET}\n"
    printf "${CYAN}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${RESET}\n\n"
    
    # For browser-based OAuth, we'll use a different approach
    # Create a special auth page on the nyanime site that handles this
    local auth_url="${NYANIME_API}/cli-auth?callback=${callback_url}"
    
    show_info "A browser window will open for authentication."
    show_info "After signing in, your token will be saved locally."
    printf "\n"
    
    open_browser "$auth_url"
    
    printf "${YELLOW}Waiting for authentication...${RESET}\n"
    printf "${DIM}(Press Ctrl+C to cancel)${RESET}\n\n"
    
    # For now, we'll use a manual token entry as fallback
    # since setting up a local HTTP server in pure shell is complex
    printf "${CYAN}If the browser didn't open, visit:${RESET}\n"
    printf "${WHITE}${auth_url}${RESET}\n\n"
    
    printf "${CYAN}After signing in, paste the token shown on the page:${RESET}\n"
    printf "${CYAN}Token: ${RESET}"
    read -r token
    
    if [ -n "$token" ]; then
        # Verify the token with Firebase
        local response
        response=$(curl -s -X POST \
            "https://identitytoolkit.googleapis.com/v1/accounts:lookup?key=${FIREBASE_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "{\"idToken\":\"${token}\"}")
        
        local email
        email=$(printf '%s' "$response" | grep -o '"email":"[^"]*"' | head -1 | cut -d'"' -f4)
        
        if [ -n "$email" ]; then
            # Save the token
            printf '{"idToken":"%s","email":"%s"}' "$token" "$email" > "$auth_file"
            show_success "Authenticated as $email"
            return 0
        else
            show_error "Invalid token"
            return 1
        fi
    else
        show_error "No token provided"
        return 1
    fi
}

auth_logout() {
    if [ -f "$auth_file" ]; then
        rm -f "$auth_file"
        show_success "Logged out successfully"
    else
        show_info "You were not logged in"
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WATCH HISTORY (Synced with Firebase Firestore)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

history_file="$data_dir/history.json"

# Local history for non-logged-in users
save_local_history() {
    local anime_id="$1"
    local anime_title="$2"
    local episode="$3"
    local timestamp
    timestamp=$(date +%s)
    
    # Create history entry
    local entry="{\"id\":\"${anime_id}\",\"title\":\"${anime_title}\",\"episode\":${episode},\"timestamp\":${timestamp}}"
    
    # Load existing history
    local history="[]"
    [ -f "$history_file" ] && history=$(cat "$history_file")
    
    # Remove existing entry for this anime and add new one
    history=$(printf '%s' "$history" | sed 's/{"id":"'"${anime_id}"'"[^}]*},\?//g' | sed 's/,]/]/g')
    
    # Add new entry at the beginning
    if [ "$history" = "[]" ]; then
        history="[$entry]"
    else
        history=$(printf '%s' "$history" | sed "s/^\[/[$entry,/")
    fi
    
    printf '%s' "$history" > "$history_file"
}

# Sync history to Firebase Firestore
sync_history_to_cloud() {
    if ! is_logged_in; then
        return
    fi
    
    local token
    token=$(get_user_token)
    local user_id
    user_id=$(get_user_id)
    
    [ -z "$token" ] || [ -z "$user_id" ] && return
    [ ! -f "$history_file" ] && return
    
    local history
    history=$(cat "$history_file")
    
    # Firestore REST API to update user's watch history
    curl -s -X PATCH \
        "https://firestore.googleapis.com/v1/projects/${FIREBASE_PROJECT_ID}/databases/(default)/documents/users/${user_id}?updateMask.fieldPaths=watchHistory" \
        -H "Authorization: Bearer ${token}" \
        -H "Content-Type: application/json" \
        -d "{\"fields\":{\"watchHistory\":{\"stringValue\":\"${history}\"}}}" >/dev/null 2>&1
}

# Fetch history from Firebase Firestore
fetch_cloud_history() {
    if ! is_logged_in; then
        return
    fi
    
    local token
    token=$(get_user_token)
    local user_id
    user_id=$(get_user_id)
    
    [ -z "$token" ] || [ -z "$user_id" ] && return
    
    local response
    response=$(curl -s \
        "https://firestore.googleapis.com/v1/projects/${FIREBASE_PROJECT_ID}/databases/(default)/documents/users/${user_id}" \
        -H "Authorization: Bearer ${token}")
    
    local cloud_history
    cloud_history=$(printf '%s' "$response" | grep -o '"watchHistory":{[^}]*}' | sed 's/.*"stringValue":"\([^"]*\)".*/\1/')
    
    if [ -n "$cloud_history" ]; then
        printf '%s' "$cloud_history" > "$history_file"
    fi
}

get_continue_watching() {
    [ ! -f "$history_file" ] && return
    cat "$history_file"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ANIME API FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Search for anime using Consumet API
search_anime() {
    local query="$1"
    local encoded_query
    encoded_query=$(url_encode "$query")
    
    show_loading "Searching"
    
    local response
    response=$(curl -s "${CONSUMET_API}/anime/gogoanime/${encoded_query}" -A "$agent")
    
    # Parse results
    printf '%s' "$response" | tr '{' '\n' | grep -o '"id":"[^"]*".*"title":"[^"]*"' | \
        sed 's/"id":"\([^"]*\)".*"title":"\([^"]*\)"/\1\t\2/' | head -20
}

# Search using Aniwatch API
search_anime_aniwatch() {
    local query="$1"
    local encoded_query
    encoded_query=$(url_encode "$query")
    
    show_loading "Searching"
    
    local response
    response=$(curl -s "${ANIWATCH_API}/anime/search?q=${encoded_query}" -A "$agent")
    
    # Parse results - extract id and name
    printf '%s' "$response" | tr '{' '\n' | grep -o '"id":"[^"]*".*"name":"[^"]*"' | \
        sed 's/"id":"\([^"]*\)".*"name":"\([^"]*\)"/\1\t\2/' | head -20
}

# Get anime info
get_anime_info() {
    local anime_id="$1"
    
    show_loading "Fetching anime info"
    
    local response
    response=$(curl -s "${ANIWATCH_API}/anime/info?id=${anime_id}" -A "$agent")
    
    printf '%s' "$response"
}

# Get episode list
get_episodes() {
    local anime_id="$1"
    
    show_loading "Fetching episodes"
    
    local response
    response=$(curl -s "${ANIWATCH_API}/anime/episodes/${anime_id}" -A "$agent")
    
    # Parse episodes
    printf '%s' "$response" | tr '{' '\n' | grep -o '"episodeId":"[^"]*".*"number":[0-9]*' | \
        sed 's/"episodeId":"\([^"]*\)".*"number":\([0-9]*\)/\2\t\1/'
}

# Get streaming links
get_stream_url() {
    local episode_id="$1"
    
    show_loading "Fetching stream"
    
    # Try to get streaming sources
    local response
    response=$(curl -s "${ANIWATCH_API}/anime/episode-srcs?id=${episode_id}" -A "$agent")
    
    # Extract m3u8 URL
    local stream_url
    stream_url=$(printf '%s' "$response" | grep -o '"url":"[^"]*\.m3u8[^"]*"' | head -1 | cut -d'"' -f4)
    
    if [ -z "$stream_url" ]; then
        # Try alternate sources
        stream_url=$(printf '%s' "$response" | grep -o '"file":"[^"]*"' | head -1 | cut -d'"' -f4)
    fi
    
    printf '%s' "$stream_url"
}

# Get subtitles
get_subtitles() {
    local episode_id="$1"
    
    local response
    response=$(curl -s "${ANIWATCH_API}/anime/episode-srcs?id=${episode_id}" -A "$agent")
    
    # Extract subtitle URL (English)
    printf '%s' "$response" | grep -o '"tracks":\[[^]]*\]' | grep -o '"file":"[^"]*".*"label":"English"' | \
        sed 's/"file":"\([^"]*\)".*/\1/' | head -1
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# RECOMMENDATIONS (AI-powered)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

get_recommendations() {
    if ! is_logged_in; then
        # Return popular anime for non-logged-in users
        show_loading "Fetching popular anime"
        local response
        response=$(curl -s "${ANIWATCH_API}/anime/home" -A "$agent")
        printf '%s' "$response" | tr '{' '\n' | grep -o '"id":"[^"]*".*"name":"[^"]*"' | \
            sed 's/"id":"\([^"]*\)".*"name":"\([^"]*\)"/\1\t\2/' | head -10
        return
    fi
    
    # For logged-in users, analyze watch history and get recommendations
    show_loading "Analyzing your taste"
    
    local history
    history=$(get_continue_watching)
    
    if [ -z "$history" ] || [ "$history" = "[]" ]; then
        # No history, return trending
        local response
        response=$(curl -s "${ANIWATCH_API}/anime/home" -A "$agent")
        printf '%s' "$response" | tr '{' '\n' | grep -o '"id":"[^"]*".*"name":"[^"]*"' | \
            sed 's/"id":"\([^"]*\)".*"name":"\([^"]*\)"/\1\t\2/' | head -10
        return
    fi
    
    # Get genre-based recommendations from watched anime
    # Extract the first watched anime ID for recommendations
    local watched_id
    watched_id=$(printf '%s' "$history" | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)
    
    if [ -n "$watched_id" ]; then
        local info
        info=$(curl -s "${ANIWATCH_API}/anime/info?id=${watched_id}" -A "$agent")
        
        # Get recommendations from this anime
        printf '%s' "$info" | grep -o '"recommendedAnimes":\[[^]]*\]' | tr '{' '\n' | \
            grep -o '"id":"[^"]*".*"name":"[^"]*"' | \
            sed 's/"id":"\([^"]*\)".*"name":"\([^"]*\)"/\1\t\2/' | head -10
    fi
}

get_random_anime() {
    show_loading "Finding a random anime"
    
    # Get a random anime from trending
    local response
    response=$(curl -s "${ANIWATCH_API}/anime/home" -A "$agent")
    
    # Extract all anime IDs and pick a random one
    local animes
    animes=$(printf '%s' "$response" | tr '{' '\n' | grep -o '"id":"[^"]*".*"name":"[^"]*"' | \
        sed 's/"id":"\([^"]*\)".*"name":"\([^"]*\)"/\1\t\2/')
    
    local count
    count=$(printf '%s\n' "$animes" | wc -l)
    
    if [ "$count" -gt 0 ]; then
        local random_index
        random_index=$(awk 'BEGIN { srand(); print int(rand() * '"$count"') + 1 }')
        printf '%s\n' "$animes" | sed -n "${random_index}p"
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PLAYER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

play_episode() {
    local stream_url="$1"
    local title="$2"
    local subtitle_url="$3"
    
    [ -z "$stream_url" ] && die "No stream URL found"
    
    show_info "Starting playback..."
    
    local sub_flag=""
    [ -n "$subtitle_url" ] && sub_flag="--sub-file=${subtitle_url}"
    
    case "$player" in
        mpv*)
            if [ -n "$sub_flag" ]; then
                $player --force-media-title="$title" "$sub_flag" "$stream_url"
            else
                $player --force-media-title="$title" "$stream_url"
            fi
            ;;
        vlc*)
            $player --meta-title="$title" "$stream_url"
            ;;
        iina*)
            $player --mpv-force-media-title="$title" "$stream_url"
            ;;
        *)
            $player "$stream_url"
            ;;
    esac
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN MENU FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

show_profile() {
    if ! is_logged_in; then
        show_info "Not logged in"
        return
    fi
    
    local email
    email=$(get_user_email)
    local name
    name=$(get_user_name)
    
    printf "\n${MAGENTA}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}  ${BOLD}ğŸ‘¤ Profile${RESET}                            ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}  ${CYAN}Name:${RESET}  %-28s ${MAGENTA}â”‚${RESET}\n" "$name"
    printf "${MAGENTA}â”‚${RESET}  ${CYAN}Email:${RESET} %-28s ${MAGENTA}â”‚${RESET}\n" "$email"
    printf "${MAGENTA}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${RESET}\n"
    
    printf "\n"
    local action
    action=$(menu_select "Profile options:" "Logout" "Back")
    
    case "$action" in
        "Logout") auth_logout ;;
    esac
}

do_search() {
    printf "\n${CYAN}ğŸ” Search anime: ${RESET}"
    read -r query
    
    [ -z "$query" ] && return
    
    local results
    results=$(search_anime_aniwatch "$query")
    
    printf "\r\033[K"  # Clear line
    
    if [ -z "$results" ]; then
        show_error "No results found"
        return
    fi
    
    # Display results
    printf "\n${CYAN}Search Results:${RESET}\n"
    printf "%s\n" "$results" | nl -w 2
    
    printf "\n${CYAN}Select anime (number): ${RESET}"
    read -r choice
    
    local selected
    selected=$(printf '%s\n' "$results" | sed -n "${choice}p")
    
    [ -z "$selected" ] && return
    
    local anime_id
    anime_id=$(printf '%s' "$selected" | cut -f1)
    local anime_title
    anime_title=$(printf '%s' "$selected" | cut -f2)
    
    watch_anime "$anime_id" "$anime_title"
}

watch_anime() {
    local anime_id="$1"
    local anime_title="$2"
    
    # Get episodes
    local episodes
    episodes=$(get_episodes "$anime_id")
    
    printf "\r\033[K"  # Clear line
    
    if [ -z "$episodes" ]; then
        show_error "No episodes found"
        return
    fi
    
    # Display episodes
    printf "\n${CYAN}Episodes for: ${WHITE}%s${RESET}\n" "$anime_title"
    printf "%s\n" "$episodes" | while IFS='	' read -r ep_num ep_id; do
        printf "${WHITE}%s)${RESET} Episode %s\n" "$ep_num" "$ep_num"
    done
    
    printf "\n${CYAN}Select episode (number or 'q' to quit): ${RESET}"
    read -r ep_choice
    
    [ "$ep_choice" = "q" ] && return
    
    local selected_ep
    selected_ep=$(printf '%s\n' "$episodes" | grep "^${ep_choice}	" | cut -f2)
    
    [ -z "$selected_ep" ] && show_error "Invalid episode" && return
    
    # Get stream URL
    local stream_url
    stream_url=$(get_stream_url "$selected_ep")
    
    printf "\r\033[K"  # Clear line
    
    if [ -z "$stream_url" ]; then
        show_error "Could not get stream URL"
        return
    fi
    
    # Get subtitles
    local subtitle_url
    subtitle_url=$(get_subtitles "$selected_ep")
    
    # Save to history
    save_local_history "$anime_id" "$anime_title" "$ep_choice"
    sync_history_to_cloud
    
    # Play
    play_episode "$stream_url" "$anime_title - Episode $ep_choice" "$subtitle_url"
    
    # After playback, offer next episode
    local next_ep=$((ep_choice + 1))
    local next_ep_id
    next_ep_id=$(printf '%s\n' "$episodes" | grep "^${next_ep}	" | cut -f2)
    
    if [ -n "$next_ep_id" ]; then
        printf "\n${CYAN}Play next episode (${next_ep})? [Y/n]: ${RESET}"
        read -r answer
        case "$answer" in
            [nN]*) ;;
            *) 
                stream_url=$(get_stream_url "$next_ep_id")
                subtitle_url=$(get_subtitles "$next_ep_id")
                save_local_history "$anime_id" "$anime_title" "$next_ep"
                sync_history_to_cloud
                play_episode "$stream_url" "$anime_title - Episode $next_ep" "$subtitle_url"
                ;;
        esac
    fi
}

do_continue_watching() {
    # Fetch from cloud first
    fetch_cloud_history
    
    local history
    history=$(get_continue_watching)
    
    if [ -z "$history" ] || [ "$history" = "[]" ]; then
        show_info "No watch history yet. Start watching something!"
        return
    fi
    
    printf "\n${CYAN}Continue Watching:${RESET}\n"
    
    # Parse and display history
    local i=1
    printf '%s' "$history" | tr '{' '\n' | grep '"id"' | while IFS= read -r entry; do
        local title
        title=$(printf '%s' "$entry" | sed 's/.*"title":"\([^"]*\)".*/\1/')
        local episode
        episode=$(printf '%s' "$entry" | sed 's/.*"episode":\([0-9]*\).*/\1/')
        local anime_id
        anime_id=$(printf '%s' "$entry" | sed 's/.*"id":"\([^"]*\)".*/\1/')
        
        printf "${WHITE}%d)${RESET} %s ${DIM}(Episode %s)${RESET}\n" "$i" "$title" "$episode"
        i=$((i + 1))
    done
    
    printf "\n${CYAN}Select to continue (number): ${RESET}"
    read -r choice
    
    [ -z "$choice" ] && return
    
    # Get selected entry
    local selected
    selected=$(printf '%s' "$history" | tr '{' '\n' | grep '"id"' | sed -n "${choice}p")
    
    [ -z "$selected" ] && return
    
    local anime_id
    anime_id=$(printf '%s' "$selected" | sed 's/.*"id":"\([^"]*\)".*/\1/')
    local anime_title
    anime_title=$(printf '%s' "$selected" | sed 's/.*"title":"\([^"]*\)".*/\1/')
    local next_episode
    next_episode=$(printf '%s' "$selected" | sed 's/.*"episode":\([0-9]*\).*/\1/')
    next_episode=$((next_episode + 1))
    
    printf "\n${CYAN}Continue from episode %s? [Y/n]: ${RESET}" "$next_episode"
    read -r answer
    
    case "$answer" in
        [nN]*) watch_anime "$anime_id" "$anime_title" ;;
        *) 
            local episodes
            episodes=$(get_episodes "$anime_id")
            local ep_id
            ep_id=$(printf '%s\n' "$episodes" | grep "^${next_episode}	" | cut -f2)
            
            if [ -n "$ep_id" ]; then
                local stream_url
                stream_url=$(get_stream_url "$ep_id")
                local subtitle_url
                subtitle_url=$(get_subtitles "$ep_id")
                save_local_history "$anime_id" "$anime_title" "$next_episode"
                sync_history_to_cloud
                play_episode "$stream_url" "$anime_title - Episode $next_episode" "$subtitle_url"
            else
                show_info "No more episodes available"
                watch_anime "$anime_id" "$anime_title"
            fi
            ;;
    esac
}

do_recommendations() {
    local recs
    recs=$(get_recommendations)
    
    printf "\r\033[K"  # Clear line
    
    if [ -z "$recs" ]; then
        show_info "No recommendations available"
        return
    fi
    
    printf "\n${CYAN}ğŸ“š Recommended for You:${RESET}\n"
    printf "%s\n" "$recs" | nl -w 2
    
    printf "\n${CYAN}Select anime (number): ${RESET}"
    read -r choice
    
    local selected
    selected=$(printf '%s\n' "$recs" | sed -n "${choice}p")
    
    [ -z "$selected" ] && return
    
    local anime_id
    anime_id=$(printf '%s' "$selected" | cut -f1)
    local anime_title
    anime_title=$(printf '%s' "$selected" | cut -f2)
    
    watch_anime "$anime_id" "$anime_title"
}

do_random() {
    local random
    random=$(get_random_anime)
    
    printf "\r\033[K"  # Clear line
    
    if [ -z "$random" ]; then
        show_error "Could not find random anime"
        return
    fi
    
    local anime_id
    anime_id=$(printf '%s' "$random" | cut -f1)
    local anime_title
    anime_title=$(printf '%s' "$random" | cut -f2)
    
    printf "\n${YELLOW}ğŸ² Random Pick: ${WHITE}%s${RESET}\n" "$anime_title"
    printf "${CYAN}Watch this? [Y/n]: ${RESET}"
    read -r answer
    
    case "$answer" in
        [nN]*) return ;;
        *) 
            # Get first episode
            local episodes
            episodes=$(get_episodes "$anime_id")
            local first_ep
            first_ep=$(printf '%s\n' "$episodes" | head -1 | cut -f2)
            
            if [ -n "$first_ep" ]; then
                local stream_url
                stream_url=$(get_stream_url "$first_ep")
                local subtitle_url
                subtitle_url=$(get_subtitles "$first_ep")
                save_local_history "$anime_id" "$anime_title" 1
                sync_history_to_cloud
                play_episode "$stream_url" "$anime_title - Episode 1" "$subtitle_url"
            else
                show_error "No episodes found"
            fi
            ;;
    esac
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN MENU
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

main_menu_guest() {
    while true; do
        show_banner
        printf "${CYAN}Welcome! Please sign in to unlock all features.${RESET}\n\n"
        
        local options="ğŸ” Search
ğŸ” Login
ğŸ“ Sign Up
â“ Help
ğŸšª Exit"
        
        printf "${CYAN}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}\n"
        printf "${CYAN}â”‚${RESET}  ${WHITE}1)${RESET} ğŸ” Search Anime                    ${CYAN}â”‚${RESET}\n"
        printf "${CYAN}â”‚${RESET}  ${WHITE}2)${RESET} ğŸ” Login                           ${CYAN}â”‚${RESET}\n"
        printf "${CYAN}â”‚${RESET}  ${WHITE}3)${RESET} ğŸ“ Sign Up                         ${CYAN}â”‚${RESET}\n"
        printf "${CYAN}â”‚${RESET}  ${WHITE}4)${RESET} â“ Help                            ${CYAN}â”‚${RESET}\n"
        printf "${CYAN}â”‚${RESET}  ${WHITE}q)${RESET} ğŸšª Exit                            ${CYAN}â”‚${RESET}\n"
        printf "${CYAN}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${RESET}\n"
        printf "\n${CYAN}Choice: ${RESET}"
        read -r choice
        
        case "$choice" in
            1) do_search ;;
            2) 
                printf "\n${CYAN}Email: ${RESET}"
                read -r email
                printf "${CYAN}Password: ${RESET}"
                stty -echo
                read -r password
                stty echo
                printf "\n"
                if auth_signin "$email" "$password"; then
                    fetch_cloud_history
                    main_menu_user
                    return
                fi
                ;;
            3)
                printf "\n${CYAN}Email: ${RESET}"
                read -r email
                printf "${CYAN}Password (min 6 chars): ${RESET}"
                stty -echo
                read -r password
                stty echo
                printf "\n"
                if auth_signup "$email" "$password"; then
                    main_menu_user
                    return
                fi
                ;;
            4) show_help ;;
            q|Q) 
                printf "\n${MAGENTA}Sayonara! ğŸ‘‹${RESET}\n"
                exit 0
                ;;
        esac
        
        printf "\n${DIM}Press Enter to continue...${RESET}"
        read -r _
    done
}

main_menu_user() {
    while true; do
        show_banner
        local name
        name=$(get_user_name)
        printf "${CYAN}Welcome back, ${WHITE}%s${CYAN}! ğŸ‰${RESET}\n\n" "$name"
        
        printf "${CYAN}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}\n"
        printf "${CYAN}â”‚${RESET}  ${WHITE}1)${RESET} ğŸ‘¤ Profile                         ${CYAN}â”‚${RESET}\n"
        printf "${CYAN}â”‚${RESET}  ${WHITE}2)${RESET} â–¶ï¸  Continue Watching               ${CYAN}â”‚${RESET}\n"
        printf "${CYAN}â”‚${RESET}  ${WHITE}3)${RESET} ğŸ” Search                          ${CYAN}â”‚${RESET}\n"
        printf "${CYAN}â”‚${RESET}  ${WHITE}4)${RESET} ğŸ“š Recommendations                 ${CYAN}â”‚${RESET}\n"
        printf "${CYAN}â”‚${RESET}  ${WHITE}5)${RESET} ğŸ² Random                          ${CYAN}â”‚${RESET}\n"
        printf "${CYAN}â”‚${RESET}  ${WHITE}6)${RESET} â“ Help                            ${CYAN}â”‚${RESET}\n"
        printf "${CYAN}â”‚${RESET}  ${WHITE}q)${RESET} ğŸšª Exit                            ${CYAN}â”‚${RESET}\n"
        printf "${CYAN}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${RESET}\n"
        printf "\n${CYAN}Choice: ${RESET}"
        read -r choice
        
        case "$choice" in
            1) show_profile ;;
            2) do_continue_watching ;;
            3) do_search ;;
            4) do_recommendations ;;
            5) do_random ;;
            6) show_help ;;
            q|Q) 
                sync_history_to_cloud
                printf "\n${MAGENTA}Sayonara! ğŸ‘‹${RESET}\n"
                exit 0
                ;;
        esac
        
        printf "\n${DIM}Press Enter to continue...${RESET}"
        read -r _
    done
}

show_help() {
    printf "\n${MAGENTA}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}  ${BOLD}NY-CLI Help${RESET}                                   ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}                                                ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}  ${CYAN}Usage:${RESET} ny-cli [options] [query]             ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}                                                ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}  ${CYAN}Options:${RESET}                                    ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    -s, --search <query>  Search for anime     ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    -c, --continue        Continue watching    ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    -r, --random          Play random anime    ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    -l, --login           Login to account     ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    -L, --logout          Logout               ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    -h, --help            Show this help       ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    -v, --version         Show version         ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}                                                ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}  ${CYAN}Environment Variables:${RESET}                      ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    NYCLI_FIREBASE_API_KEY    Firebase API key ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    NYCLI_FIREBASE_AUTH_DOMAIN  Auth domain    ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    NYCLI_FIREBASE_PROJECT_ID   Project ID     ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    NYCLI_PLAYER              Video player     ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    NYCLI_QUALITY             Video quality    ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}                                                ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}  ${CYAN}Examples:${RESET}                                   ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    ny-cli                  Interactive mode   ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    ny-cli -s \"one piece\"   Search directly    ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    ny-cli -c               Continue watching  ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}    ny-cli -r               Random anime       ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â”‚${RESET}                                                ${MAGENTA}â”‚${RESET}\n"
    printf "${MAGENTA}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${RESET}\n"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN ENTRY POINT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

main() {
    # Check dependencies
    dep_check "curl" "sed" "grep"
    
    # Ensure directories exist
    ensure_dirs
    
    # Parse command line arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                printf "ny-cli version %s\n" "$version_number"
                exit 0
                ;;
            -s|--search)
                shift
                query="$1"
                show_banner
                if [ -n "$query" ]; then
                    local results
                    results=$(search_anime_aniwatch "$query")
                    if [ -n "$results" ]; then
                        printf "\n${CYAN}Search Results:${RESET}\n"
                        printf "%s\n" "$results" | nl -w 2
                        printf "\n${CYAN}Select anime (number): ${RESET}"
                        read -r choice
                        local selected
                        selected=$(printf '%s\n' "$results" | sed -n "${choice}p")
                        if [ -n "$selected" ]; then
                            local anime_id
                            anime_id=$(printf '%s' "$selected" | cut -f1)
                            local anime_title
                            anime_title=$(printf '%s' "$selected" | cut -f2)
                            watch_anime "$anime_id" "$anime_title"
                        fi
                    else
                        show_error "No results found"
                    fi
                fi
                exit 0
                ;;
            -c|--continue)
                show_banner
                do_continue_watching
                exit 0
                ;;
            -r|--random)
                show_banner
                do_random
                exit 0
                ;;
            -l|--login)
                show_banner
                printf "\n${CYAN}Email: ${RESET}"
                read -r email
                printf "${CYAN}Password: ${RESET}"
                stty -echo
                read -r password
                stty echo
                printf "\n"
                auth_signin "$email" "$password"
                exit 0
                ;;
            -L|--logout)
                auth_logout
                exit 0
                ;;
            *)
                # Treat as search query
                query="$*"
                show_banner
                if [ -n "$query" ]; then
                    local results
                    results=$(search_anime_aniwatch "$query")
                    if [ -n "$results" ]; then
                        printf "\n${CYAN}Search Results:${RESET}\n"
                        printf "%s\n" "$results" | nl -w 2
                        printf "\n${CYAN}Select anime (number): ${RESET}"
                        read -r choice
                        local selected
                        selected=$(printf '%s\n' "$results" | sed -n "${choice}p")
                        if [ -n "$selected" ]; then
                            local anime_id
                            anime_id=$(printf '%s' "$selected" | cut -f1)
                            local anime_title
                            anime_title=$(printf '%s' "$selected" | cut -f2)
                            watch_anime "$anime_id" "$anime_title"
                        fi
                    else
                        show_error "No results found"
                    fi
                fi
                exit 0
                ;;
        esac
        shift
    done
    
    # No arguments, run interactive mode
    if is_logged_in; then
        fetch_cloud_history
        main_menu_user
    else
        main_menu_guest
    fi
}

# Run main
main "$@"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LICENSE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# ny-cli - Terminal-based anime streaming client
# Copyright (C) 2024 Anjishnu Sengupta
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the MIT License.
#
# Project repository: https://github.com/AnjishnuSengupta/ny-cli
# Website: https://nyanime.tech
